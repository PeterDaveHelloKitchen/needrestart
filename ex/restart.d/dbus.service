#!/bin/sh

# by Vladimir Kudrya
# https://github.com/Vladimir-csp/
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version. See <http://www.gnu.org/licenses/>.

# This is a replacement for original dbus.service script by Thomas Liske <thomas@fiasko-nw.net>
# Dbus dependencies are enumerated dynamically and restarted after dbus and systemd daemon reexec

# delay in non-interactive mode
NONINTERACTIVE_DELAY=10

# enable xtrace if we should be verbose
if [ "$NR_VERBOSE" = '1' ]; then
	set -x
fi

if [ "$(id -ru)" != "0" ]
then
	echo "Not root, exiting" >&2
	exit 1
fi

INIT_EXEC="$(readlink /proc/1/exe)"

if [ "$(basename "$INIT_EXEC")" != "systemd" ]
then
	echo "Init system is not systemd ($INIT_EXEC), doing nothing"
	exit 0
fi

# start from the name of the hook, get real unit ID (for example, dbus-broker replaces dbus)
DBUS_SERVICE_NAME=$(
	systemctl show --value -p Id "$(basename "$0")"
)

# if DM is active, return canonical ID
DISPLAY_MANAGER=$(
	systemctl -q is-active display-manager.service && \
	  systemctl show --value -p Id display-manager.service
)

# get dependencies
ACTIVE_DEPS=$(
	# return all dbus dependencies, filter out dbus and DM, leave only active
	{
		systemctl list-dependencies -l --reverse --plain dbus.socket
		systemctl list-dependencies -l --reverse --plain $DBUS_SERVICE_NAME
	} | grep -o '[^[:space:]]\+.service' | sort -u | while read SERVICE
	do
		if [ "$SERVICE" != "$DBUS_SERVICE_NAME" ] && \
		  [ "$SERVICE" != "$DISPLAY_MANAGER" ] && \
		  systemctl -q is-active "$SERVICE"
		then
			echo "$SERVICE"
		fi
	done | tr '\n' ' ' | tr -s ' '
)

# get logind sessions
SESSIONS=$(loginctl list-sessions --no-legend | grep -o '^[[:space:]]*[0-9]\+' | tr '\n' ' ')

# get current dbus service PIDs
DBUS_PIDS=$(
	ps -eo pid,unit | grep -E "[[:space:]]+${DBUS_SERVICE_NAME}[[:space:]]*$" \
	  | grep -oE '^[[:space:]]*[0-9]+' \
	  | tr '\n' ' ' | tr -s ' '
)

# assemble commands
COMMANDS=''
# terminate sessions
[ -n "$SESSIONS" ] && COMMANDS="${COMMANDS}${COMMANDS:+ ; }loginctl terminate-session $SESSIONS"
# stop display manager
[ -n "$DISPLAY_MANAGER" ] && COMMANDS="${COMMANDS}${COMMANDS:+ ; }systemctl stop $DISPLAY_MANAGER"
# restart dbus
COMMANDS="${COMMANDS}${COMMANDS:+ ; }sleep 1 ; systemctl restart $DBUS_SERVICE_NAME"
# kill previous dbus pids
[ -n "$DBUS_PIDS" ] && COMMANDS="${COMMANDS}${COMMANDS:+ ; }sleep 1 ; kill $DBUS_PIDS 2>/dev/null"
# restart active dependencies
COMMANDS="${COMMANDS}${COMMANDS:+ ; }sleep 1 ; systemctl restart $ACTIVE_DEPS"
# start display manager
[ -n "$DISPLAY_MANAGER" ] && COMMANDS="${COMMANDS}${COMMANDS:+ ; }systemctl start $DISPLAY_MANAGER"
# normalize to single line
COMMANDS=$(echo "$COMMANDS" | tr '\n' ' ' | tr -s ' ')

if [ -t 0 ]
then
	INTERACTIVE=true
else
	INTERACTIVE=false
fi

if [ "$INTERACTIVE" = "true" ]
then
	cat
else
	cat >&2
fi << EOF
!!! $DBUS_SERVICE_NAME restart will be performed !!!

User sessions to be terminated: $SESSIONS

Services to be restarted:
$(echo $ACTIVE_DEPS | tr ' ' '\n' | sed 's/^/  /')

Display manager to be restarted: ${DISPLAY_MANAGER:-no active DM found}

Command set to run as transient unit restart-dbus.service:
  $(echo $COMMANDS | sed -r 's/ ; /\n  /g')

Logs can be viewed by: journalctl -u restart-dbus
EOF

# if interactive, ask for continuation
if [ "$INTERACTIVE" = "true" ]
then
	read -p "
Press Enter to continue > " PRESSENTER
else
	echo "
Restart in $NONINTERACTIVE_DELAY seconds..." >&2
	sleep $NONINTERACTIVE_DELAY
	echo "Restarting..." >&2
fi

# run restart sequence as transient unit...
# it is possible to view its output in the log if any:
# journalctl -u restart-dbus
systemd-run -G --unit=restart-dbus --description="transient dbus restarter" sh -c "$COMMANDS"
